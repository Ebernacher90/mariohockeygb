
INCLUDE "inc/gbhw.z80"              ; standard hardware definitions from devrs.com

; Include tiles
INCLUDE "resources/cut-constants.inc"

; Include Memory location definitions
INCLUDE "inc/memory-locations.inc"


        
; IRQs
SECTION "Vblank",HOME[$0040]
        jp      CURRENT_VBLANK_HNDLR
SECTION "LCDC",HOME[$0048]
        reti
SECTION "Timer_Overflow",HOME[$0050]
        reti
SECTION "Serial",HOME[$0058]
        reti
SECTION "p1thru4",HOME[$0060]
        reti

; ****************************************************************************************
; boot loader jumps to here.
; ****************************************************************************************
SECTION "start",HOME[$0100]
        nop
        jp      begin

; ****************************************************************************************
; ROM HEADER and ASCII character set
; ****************************************************************************************
; ROM header
    ROM_HEADER  ROM_NOMBC, ROM_SIZE_32KBYTE, RAM_SIZE_0KBYTE

INCLUDE "inc/memory.z80"

; ****************************************************************************************
; Main code Initialization:
; set the stack pointer, enable interrupts, set the palette, set the screen relative to the window
; copy the ASCII character table, clear the screen
; ****************************************************************************************
begin:
        nop
        di
        ld      sp, $ffff               ; set the stack pointer to highest mem location + 1

; Configure animation (VBLANK) handler. On every VBLANK interrupt we increase our frame Counter
; and then call a custom animation routine that handles whatever animation needs to happen
        call    ClearFrameCounter
        ld      hl,CURRENT_VBLANK_HNDLR ; Enable Fade animation by setting as current animation CALL FadeInHandler to first 3 bytes
        ld      de,UpdateAnimation
        ld      a,$cd                   ; CALL opcode
        ld      [hl+],a
        ld      a,e
        ld      [hl+],a
        ld      a,d
        ld      [hl+],a
        xor     a                       ; COPY 0 (NOP) to next 3 bytes
        ld      [hl+],a
        ld      [hl+],a
        ld      [hl+],a
        ld      a,$d9                   ; COPY a RETI instruction
        ld      [hl+],a

        xor     a                       ; Disable animation
        ld      [ANIMATION_ACTIVE], a

; NEXT FOUR LINES FOR SETTING UP SPRITES *hs*
        ld      a, IEF_VBLANK
        ld      [rIE],a                 ; ENABLE ONLY VBLANK INTERRUPT

        ei                              ; LET THE INTS FLY

init:
        ld      a, %11100100            ; Window palette colors, from darkest to lightest
        ld      [rBGP], a               ; set background and window pallette
        ldh     [rOBP0],a               ; set sprite pallette 0 (choose palette 0 or 1 when describing the sprite)
        ldh     [rOBP1],a               ; set sprite pallette 1

        xor     a                       ; SET SCREEN TO TO UPPER RIGHT HAND CORNER
        ld      [rSCX], a
        ld      [rSCY], a               

        ; *hs* see gbspec.txt lines 1525-1565 and gbhw.inc lines 70-86
        ld      a, LCDCF_ON|LCDCF_BG8000|LCDCF_BG9800|LCDCF_BGON|LCDCF_OBJ8|LCDCF_OBJOFF
        ld      [rLCDC], a

; -------------------------------------------------------------------------------------------
; Cut 01
; -------------------------------------------------------------------------------------------
cut01:

        ; Set palette to 0 so that we don't see anything
        ld      a, %11111111
        ld      [rBGP], a

        ; Load bitmap
        ld      hl, cut01_tile_data
        ld      de, _VRAM               ; $8000
        ld      bc, cut01_tile_data_size     ; 128 tiles
        call    mem_CopyVRAM            ; load tile data

        ld      a, 0
        ld      de, _SCRN0
        ld      hl, cut01_map_data
        ld      bc, SCRN_VX_B * SCRN_VY_B
        call    mem_CopyVRAM

        call    StartLCD

        ; Trigger FadeIn Animation
        ld      de,FadeInHandler
        call    SetAnimationHandler
        call    WaitAnimation

        ; Wait a bit
        ld      de,ShortDelayHandler
        call    SetAnimationHandler
        call    WaitAnimation
 
        ; Trigger FadeOut Animation
        ld      de,FadeOutHandler
        call    SetAnimationHandler
        call    WaitAnimation

; -------------------------------------------------------------------------------------------
; Cut 02
; -------------------------------------------------------------------------------------------
cut02:

        ; Load bitmap
        ld      hl, cut02_tile_data
        ld      de, _VRAM
        ld      bc, cut02_tile_data_size    
        call    mem_CopyVRAM

        ld      a, 0
        ld      de, _SCRN0
        ld      hl, cut02_map_data
        ld      bc, SCRN_VX_B * SCRN_VY_B
        call    mem_CopyVRAM

        ; Trigger FadeIn Animation
        ld      de,FadeInHandler
        call    SetAnimationHandler
        call    WaitAnimation

        ; Wait a bit
        ld      de,ShortDelayHandler
        call    SetAnimationHandler
        call    WaitAnimation
 
        ; Trigger FadeOut Animation
        ld      de,FadeOutHandler
        call    SetAnimationHandler
        call    WaitAnimation
 
; -------------------------------------------------------------------------------------------
; Cut 03
; -------------------------------------------------------------------------------------------
cut03:

        ; Load bitmap
        ld      hl, cut03_tile_data
        ld      de, _VRAM               ; $8000
        ld      bc, cut03_tile_data_size     ; 128 tiles
        call    mem_CopyVRAM            ; load tile data

        ld      a, 0
        ld      de, _SCRN0
        ld      hl, cut03_map_data
        ld      bc, SCRN_VX_B * SCRN_VY_B
        call    mem_CopyVRAM

        ; Move screen position
        ld      a, 37
        ld      [rSCX], a
        ld      a, 74
        ld      [rSCY], a

        ; Trigger FadeIn Animation
        ld      de,FadeInHandler
        call    SetAnimationHandler
        call    WaitAnimation

        ; Trigger Scroll Animation
        ld      de,ScrollHandNW
        call    SetAnimationHandler
        call    WaitAnimation

        ; Wait a bit
        ld      de,ShortDelayHandler
        call    SetAnimationHandler
        call    WaitAnimation
 
        ; Trigger FadeOut Animation
        ld      de,FadeOutHandler
        call    SetAnimationHandler
        call    WaitAnimation
 
; -------------------------------------------------------------------------------------------
; Cut 04
; -------------------------------------------------------------------------------------------
cut04:

        ; Load bitmap
        ld      hl, cut04_tile_data
        ld      de, _VRAM               ; $8000
        ld      bc, cut04_tile_data_size     ; 128 tiles
        call    mem_CopyVRAM            ; load tile data

        ld      a, 0
        ld      de, _SCRN0
        ld      hl, cut04_map_data
        ld      bc, SCRN_VX_B * SCRN_VY_B
        call    mem_CopyVRAM

        ; Turn on regular palette
        ld      a,%11100100
        ld      [rBGP], a

        ; Remove last animation handler
        call    ClearAnimationHandler

        ;
        ; Animation loop
        ;
        lcd_WaitVBlank                  ; Wait for VBlank to start
        ld      a, $20                  ; Save initial separation to stack
        ld      [ANIMATION_VAR_01], a
        ld      a, -$20                  ; Save initial separation to stack
        ld      [ANIMATION_VAR_02], a

        xor     a                       ; Make sure SCX = 0
        ld      [rSCX], a

        call    ClearFrameCounter       ; Start animation counter
        ld      a, $1
        ld      [ANIMATION_ACTIVE], a

.animation_loop:
        lcd_WaitLine    $30
        ld      a, [ANIMATION_VAR_01]
        ld      [rSCX], a

        lcd_WaitLine    $40
        ld      a, [ANIMATION_VAR_02]
        ld      [rSCX], a

        lcd_WaitLine    $50
        ld      a, [ANIMATION_VAR_01]
        ld      [rSCX], a

        lcd_WaitLine    $60
        ld      a, [ANIMATION_VAR_02]
        ld      [rSCX], a
        
        lcd_WaitLine    $70
        ld      a, [ANIMATION_VAR_01]
        ld      [rSCX], a

.wait_vblank
        lcd_WaitVBlank

        ld      a, [ANIMATION_VAR_02]
        ld      [rSCX], a

        ; Wait for 1 line again
        ld      a,[rLY]
        cp      $1
        jr      nz,@-4

        ld      a, [ANIMATION_VAR_01]
        dec     a
        dec     a
        cp      $0
        jp      z,.finish_loop
        ld      [ANIMATION_VAR_01],a
        ld      a, [ANIMATION_VAR_02]
        inc     a
        inc     a
        ld      [ANIMATION_VAR_02],a
        jp      .animation_loop

.finish_loop:
 
        ; Wait a bit
        ld      de,ShortDelayHandler
        call    SetAnimationHandler
        call    WaitAnimation
        call    WaitAnimation
 
        ; Trigger FadeOut Animation
        ld      de,FadeOutHandler
        call    SetAnimationHandler
        call    WaitAnimation
 
MainLoop:
        halt
        nop                             ; always put NOP after HALT (gbspec.txt lines 514-578)
        jr      MainLoop

; -------------------------------------------------------------------------------------------
; Scroll screen NW for Cut 3
; -------------------------------------------------------------------------------------------
ScrollHandNW:
        push    af
        ld      a,[ANIMATION_ACTIVE]    ; Check if animation is active
        jp      z, .return
        ld      a,[FRAME_COUNTER+1]
        and     %00000011               ; Update every 4 ticks
        jp      nz, .return
        ld      a,[rSCX]
        dec     a
        jp      z, .stop_animation
        ld      [rSCX], a
        ld      a,[rSCY]
        dec     a
        dec     a
        jp      z, .stop_animation
        ld      [rSCY], a
        jp      .return
.stop_animation
        xor     a                       ; Done. Turn off animation
        ld      [ANIMATION_ACTIVE],a
.return
        pop     af
        ret


; -------------------------------------------------------------------------------------------
; Fade In Animation
; -------------------------------------------------------------------------------------------
FadeInHandler:
        push    af
        ld      a,[FRAME_COUNTER+1]
        cp      $20
        jp      c, .return
        cp      $30
        jp      c, .fade_step_01
        cp      $39
        jp      c, .fade_step_02
        cp      $40
        jp      c, .fade_step_03
        xor     a                       ; Done. Turn off animation
        ld      [ANIMATION_ACTIVE],a
        jp      .return
.fade_step_01:
        ld      a,%11111110
        ld      [rBGP], a
        jp      .return
.fade_step_02:
        ld      a,%11111001
        ld      [rBGP], a
        jp      .return
.fade_step_03:
        ld      a,%11100100
        ld      [rBGP], a
.return
        pop     af
        ret

; -------------------------------------------------------------------------------------------
; Fade Out Animation
; -------------------------------------------------------------------------------------------
FadeOutHandler:
        push    af
        ld      a,[FRAME_COUNTER+1]
        cp      $20
        jp      c, .return
        cp      $30
        jp      c, .fade_step_01
        cp      $39
        jp      c, .fade_step_02
        cp      $40
        jp      c, .fade_step_03
        xor     a                       ; Done. Turn off animation
        ld      [ANIMATION_ACTIVE],a
        jp      .return
.fade_step_01:
        ld      a,%11111001
        ld      [rBGP], a
        jp      .return
.fade_step_02:
        ld      a,%11111110
        ld      [rBGP], a
        jp      .return
.fade_step_03:
        ld      a,%11111111
        ld      [rBGP], a
.return
        pop     af
        ret

; -------------------------------------------------------------------------------------------
; Short Delay Animation
; -------------------------------------------------------------------------------------------
ShortDelayHandler:
        ld      a,[FRAME_COUNTER+1]
        cp      $20
        jp      c, .return
        xor     a                       ; Done. Turn off animation
        ld      [ANIMATION_ACTIVE],a
.return
        ret
 
; ****************************************************************************************
; StopLCD:
; turn off LCD if it is on
; and wait until the LCD is off
; ****************************************************************************************
StopLCD:
        ld      a,[rLCDC]
        rlca                    ; Put the high bit of LCDC into the Carry flag
        ret     nc              ; Screen is off already. Exit.

; Loop until we are in VBlank
.wait:
        ld      a,[rLY]
        cp      145             ; Is display on scan line 145 yet?
        jr      nz,.wait        ; no, keep waiting

; Turn off the LCD

        ld      a,[rLCDC]
        res     7,a             ; Reset bit 7 of LCDC
        ld      [rLCDC],a

        ret

StartLCD:
        ld      a,[rLCDC]
        set     7,a             ; Set bit 7 of LCDC
        ld      [rLCDC], a
        ret

; ****************************************************************************************
; Update Animation Counter
; If the ANIMATION_ACTIVE flag is set increase frame counter
; ****************************************************************************************
UpdateAnimation:
        push    af
        push    hl
        ld      a,[ANIMATION_ACTIVE]    ; Check if animation is active
        jp      z, .return
        ld      a,[FRAME_COUNTER]
        ld      h,a
        ld      a,[FRAME_COUNTER + 1]
        ld      l,a
        inc     hl
        ld      a,h
        ld      [FRAME_COUNTER],a
        ld      a,l
        ld      [FRAME_COUNTER + 1],a
.return
        pop     hl
        pop     af
        ret

; Clear frame counter
ClearFrameCounter:
        xor     a
        ld      [FRAME_COUNTER],a
        ld      [FRAME_COUNTER + 1],a
        ret

; ------------------------------------------------------------------------------------------
; Set current animation handler to routine in location given by register DE
; ------------------------------------------------------------------------------------------
SetAnimationHandler:
        push    hl
        push    af
        ld      hl,CURRENT_VBLANK_HNDLR + 3
        ld      a,$cd                           ; CALL opcode
        ld      [hl+],a
        ld      a,e
        ld      [hl+],a
        ld      a,d
        ld      [hl+],a
        pop     af
        pop     hl
        ret

ClearAnimationHandler:
        push    hl
        ld      hl,CURRENT_VBLANK_HNDLR + 3
        xor     a
        ld      [hl+],a
        ld      [hl+],a
        ld      [hl+],a
        pop     hl
        ret


WaitAnimation:
        xor     a
        ld      [FRAME_COUNTER],a
        ld      [FRAME_COUNTER + 1],a
        inc     a
        ld      [ANIMATION_ACTIVE],a

.loop
        ld      a,[ANIMATION_ACTIVE]
        cp      $0
        jp      z, .done
        halt
        nop
        jp      .loop
.done
        ret

        

; ****************************************************************************************
; RESOURCES - back 1
; ****************************************************************************************

SECTION "Resources",ROMX
INCLUDE "resources/cut-01.inc"
INCLUDE "resources/cut-02.inc"
INCLUDE "resources/cut-03.inc"
INCLUDE "resources/cut-04.inc"

; vim: se ts=8 sw=8 expandtab:
